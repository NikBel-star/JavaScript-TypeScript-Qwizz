<!DOCTYPE html>
<html lang="ka">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript & TypeScript ქვიზი</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Georgian:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans Georgian', sans-serif;
        }
        .quiz-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
            min-height: 100vh;
        } 
        .card {
            backdrop-filter: blur(20px);
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .option-btn {
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .option-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        .option-btn.correct {
            background: linear-gradient(135deg, #10b981, #059669);
            border-color: #059669;
            color: white;
        }
        .option-btn.incorrect {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border-color: #dc2626;
            color: white;
        }
        .progress-bar {
            background: linear-gradient(90deg, #10b981, #059669);
            height: 8px;
            border-radius: 4px;
            transition: width 0.5s ease;
        }
        .category-card {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .category-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }
        .explanation {
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            border-left: 4px solid #0ea5e9;
        }
        .pulse {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .language-btn {
            border: 2px solid transparent;
        }
        .language-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .language-btn.active {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            border-color: #1d4ed8;
            color: white;
        }
    </style>
</head>
<body class="quiz-container">
    <div class="container mx-auto px-4 py-8">
        <!-- Language Switcher Header -->
        <div class="flex justify-end mb-6">
            <div class="card rounded-xl p-3 shadow-lg">
                <div class="flex space-x-2">
                    <button onclick="switchLanguage('ge')"
                        class="language-btn px-4 py-2 rounded-lg font-medium transition-all duration-200 bg-blue-600 text-white active">
                        <i class="fas fa-globe mr-2"></i>ქართული
                    </button>
                    <button onclick="switchLanguage('en')"
                        class="language-btn px-4 py-2 rounded-lg font-medium transition-all duration-200 bg-gray-200 text-gray-700 hover:bg-gray-300">
                        <i class="fas fa-globe mr-2"></i>English
                    </button>
                </div>
            </div>
        </div>

        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold text-white mb-4">
                <i class="fas fa-code mr-3"></i>JavaScript & TypeScript ქვიზი
            </h1>
            <p class="text-xl text-white opacity-90">შეამოწმეთ თქვენი ცოდნა პროგრამირებაში</p>
        </div>

        <!-- Main Menu -->
        <div id="mainMenu" class="max-w-4xl mx-auto">
            <div class="grid md:grid-cols-3 gap-6">
                <!-- JavaScript Beginner -->
                <div class="category-card card rounded-2xl p-6 shadow-xl" onclick="startQuiz('jsBeginner')">
                    <div class="text-center">
                        <div class="text-4xl mb-4">
                            <i class="fab fa-js-square text-yellow-500"></i>
                        </div>
                        <h3 class="text-2xl font-bold text-gray-800 mb-3">JavaScript დამწყები</h3>
                        <p class="text-gray-600 mb-4">ძირითადი კონცეფციები და სინტაქსი</p>
                        <div class="flex justify-center space-x-4 text-sm text-gray-500">
                            <span><i class="fas fa-clock mr-1"></i>10 წუთი</span>
                            <span><i class="fas fa-question-circle mr-1"></i>12 კითხვა</span>
                        </div>
                    </div>
                </div>
                <!-- JavaScript Medium -->
                <div class="category-card card rounded-2xl p-6 shadow-xl" onclick="startQuiz('jsMedium')">
                    <div class="text-center">
                        <div class="text-4xl mb-4">
                            <i class="fab fa-js-square text-yellow-500"></i>
                        </div>
                        <h3 class="text-2xl font-bold text-gray-800 mb-3">JavaScript საშუალო</h3>
                        <p class="text-gray-600 mb-4">ძირითადი კონცეფციები და სინტაქსი</p>
                        <div class="flex justify-center space-x-4 text-sm text-gray-500">
                            <span><i class="fas fa-clock mr-1"></i>10 წუთი</span>
                            <span><i class="fas fa-question-circle mr-1"></i>12 კითხვა</span>
                        </div>
                    </div>
                </div>
                <!-- JavaScript Advanced -->
                <div class="category-card card rounded-2xl p-6 shadow-xl" onclick="startQuiz('jsAdvanced')">
                    <div class="text-center">
                        <div class="text-4xl mb-4">
                            <i class="fab fa-js-square text-yellow-600"></i>
                        </div>
                        <h3 class="text-2xl font-bold text-gray-800 mb-3">JavaScript მოწინავე</h3>
                        <p class="text-gray-600 mb-4">რთული კონცეფციები და შაბლონები</p>
                        <div class="flex justify-center space-x-4 text-sm text-gray-500">
                            <span><i class="fas fa-clock mr-1"></i>15 წუთი</span>
                            <span><i class="fas fa-question-circle mr-1"></i>13 კითხვა</span>
                        </div>
                    </div>
                </div>
                <!-- TypeScript Beginner -->
                <div class="category-card card rounded-2xl p-6 shadow-xl" onclick="startQuiz('tsBeginner')">
                    <div class="text-center">
                        <div class="text-4xl mb-4">
                            <i class="fas fa-code text-blue-500"></i>
                        </div>
                        <h3 class="text-2xl font-bold text-gray-800 mb-3">TypeScript დამწყები</h3>
                        <p class="text-gray-600 mb-4">ტიპები და ძირითადი გამოყენება</p>
                        <div class="flex justify-center space-x-4 text-sm text-gray-500">
                            <span><i class="fas fa-clock mr-1"></i>10 წუთი</span>
                            <span><i class="fas fa-question-circle mr-1"></i>12 კითხვა</span>
                        </div>
                    </div>
                </div>
                <!-- TypeScript Medium -->
                <div class="category-card card rounded-2xl p-6 shadow-xl" onclick="startQuiz('tsMedium')">
                    <div class="text-center">
                        <div class="text-4xl mb-4">
                            <i class="fas fa-code text-blue-500"></i>
                        </div>
                        <h3 class="text-2xl font-bold text-gray-800 mb-3">TypeScript საშუალო</h3>
                        <p class="text-gray-600 mb-4">ტიპები და ძირითადი გამოყენება</p>
                        <div class="flex justify-center space-x-4 text-sm text-gray-500">
                            <span><i class="fas fa-clock mr-1"></i>10 წუთი</span>
                            <span><i class="fas fa-question-circle mr-1"></i>12 კითხვა</span>
                        </div>
                    </div>
                </div>
                <!-- TypeScript Advanced -->
                <div class="category-card card rounded-2xl p-6 shadow-xl" onclick="startQuiz('tsAdvanced')">
                    <div class="text-center">
                        <div class="text-4xl mb-4">
                            <i class="fas fa-code text-blue-600"></i>
                        </div>
                        <h3 class="text-2xl font-bold text-gray-800 mb-3">TypeScript მოწინავე</h3>
                        <p class="text-gray-600 mb-4">მოწინავე ტიპები და არქიტექტურა</p>
                        <div class="flex justify-center space-x-4 text-sm text-gray-500">
                            <span><i class="fas fa-clock mr-1"></i>15 წუთი</span>
                            <span><i class="fas fa-question-circle mr-1"></i>12 კითხვა</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Stats Section -->
            <div class="mt-8 card rounded-2xl p-6 shadow-xl">
                <h3 class="text-xl font-bold text-gray-800 mb-4 text-center">
                    <i class="fas fa-chart-line mr-2"></i>თქვენი სტატისტიკა
                </h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-600" id="totalQuizzes">0</div>
                        <div class="text-sm text-gray-600">მოსრულებული ქვიზები</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-green-600" id="averageScore">0%</div>
                        <div class="text-sm text-gray-600">საშუალო ქულა</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-purple-600" id="bestCategory">-</div>
                        <div class="text-sm text-gray-600">საუკეთესო კატეგორია</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-orange-600" id="timeSpent">0 წთ</div>
                        <div class="text-sm text-gray-600">დახარჯული დრო</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quiz Interface -->
        <div id="quizInterface" class="max-w-4xl mx-auto hidden">
            <!-- Quiz Header -->
            <div class="card rounded-2xl p-6 shadow-xl mb-6">
                <div class="flex justify-between items-center mb-4">
                    <button onclick="backToMenu()" class="text-blue-600 hover:text-blue-800 transition-colors">
                        <i class="fas fa-arrow-left mr-2"></i>მთავარ მენიუში დაბრუნება
                    </button>
                    <div class="text-right">
                        <div class="text-sm text-gray-600">კითხვა <span id="currentQuestion">1</span> / <span id="totalQuestions">8</span></div>
                        <div class="text-sm text-gray-600">ქულა: <span id="currentScore">0</span></div>
                    </div>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2">
                    <div class="progress-bar h-2 rounded-full" id="progressBar" style="width: 0%"></div>
                </div>
            </div>

            <!-- Question Card -->
            <div class="card rounded-2xl p-8 shadow-xl mb-6">
                <h2 class="text-2xl font-bold text-gray-800 mb-6" id="questionTitle">კითხვა იტვირთება...</h2>
                <pre class="bg-gray-100 p-4 rounded-lg mb-6 overflow-x-auto" id="codeBlock" style="display:none;"><code></code></pre>
                <div id="optionsContainer" class="space-y-3">
                    <!-- Options will be populated here -->
                </div>
            </div>

            <!-- Explanation Card -->
            <div id="explanationCard" class="card rounded-2xl p-6 shadow-xl mb-6 hidden">
                <div class="explanation rounded-lg p-6">
                    <h3 class="text-lg font-bold text-gray-800 mb-3">
                        <i class="fas fa-lightbulb mr-2"></i>ახსნა
                    </h3>
                    <div id="explanationText" class="text-gray-700"></div>
                </div>
                <button onclick="nextQuestion()" class="mt-4 bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg transition-colors">
                    <i class="fas fa-arrow-right mr-2"></i>შემდეგი კითხვა
                </button>
            </div>
        </div>

        <!-- Results Screen -->
        <div id="resultsScreen" class="max-w-4xl mx-auto hidden">
            <div class="card rounded-2xl p-8 shadow-xl text-center">
                <div class="text-6xl mb-6" id="resultIcon">🎉</div>
                <h2 class="text-3xl font-bold text-gray-800 mb-4" id="resultTitle">შესანიშნავია!</h2>
                <div class="text-6xl font-bold text-blue-600 mb-6" id="finalScore">0%</div>
                <div class="grid md:grid-cols-3 gap-6 mb-8">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-green-600" id="correctAnswers">0</div>
                        <div class="text-gray-600">სწორი პასუხი</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-red-600" id="wrongAnswers">0</div>
                        <div class="text-gray-600">არასწორი პასუხი</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-600" id="timeTaken">0 წთ</div>
                        <div class="text-gray-600">დახარჯული დრო</div>
                    </div>
                </div>
                <div class="space-y-4">
                    <button onclick="restartQuiz()" class="bg-blue-600 hover:bg-blue-700 text-white px-8 py-3 rounded-lg mr-4 transition-colors">
                        <i class="fas fa-redo mr-2"></i>კვლავ სცადეთ
                    </button>
                    <button onclick="backToMenu()" class="bg-gray-600 hover:bg-gray-700 text-white px-8 py-3 rounded-lg transition-colors">
                        <i class="fas fa-home mr-2"></i>მთავარ მენიუში დაბრუნება
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Quiz Data (შემოკლებული ვერსია სიგრძის შესამცირებლად)
        const quizData = {
            jsBeginner: [
                {
                    question:"რა არის function declaration?",
                    code: `// რომელია სწორი?
a) function myFunc() {}
b) var myFunc = function() {}
c) let myFunc = () => {}
d) ყველა სწორია`,
                    options: [
                        "a) function myFunc() {}",
                        "b) var myFunc = function() {}",
                        "c) let myFunc = () => {}",
                        "d) ყველა სწორია"
                    ],
                    correct: 0,
                    explanation: "Function declaration არის ფუნქციის განსაზღვრა function keyword-ით."
                },
                {
                    question:"რა არის function expression?",
                    code: `// რომელია სწორი?
a) function myFunc() {}
b) var myFunc = function() {}
c) let myFunc = () => {}
d) ყველა სწორია`,
                    options: [
                        "a) function myFunc() {}",
                        "b) var myFunc = function() {}",
                        "c) let myFunc = () => {}",
                        "d) ყველა სწორია"
                    ],
                    correct: 1,
                    explanation: "Function expression არის ფუნქციის განსაზღვრა რაიმე ცვლადის მიერ."
                },
                {
                    question:"რა არის arrow function?",
                    code: `// რომელია სწორი?
a) function myFunc() {}
b) var myFunc = function() {}
c) let myFunc = () => {}
d) ყველა სწორია`,
                    options: [
                        "a) function myFunc() {}",
                        "b) var myFunc = function() {}",
                        "c) let myFunc = () => {}",
                        "d) ყველა სწორია"
                    ],
                    correct: 2,
                    explanation: "Arrow function არის ფუნქციის განსაზღვრა სიმბოლოთ () => გამოყენებით."
                },
                {
                    question:"რა არის არგუმენტი?",
                    code: `// რომელია სწორი?
a) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობა
b) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლო
c) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლოს ტიპი
d) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობა"`,
                    options: [
                        "a) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობა",
                        "b) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლო",
                        "c) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლოს ტიპი",
                        "d) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობა"
                    ],
                    correct: 3, 
                    explanation: "არგუმენტი არის ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობა."
                },
                {
                    question:"რა არის პარამეტრი?",
                    code: `// რომელია სწორი?
a) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობა
b) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლო
c) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლოს ტიპი
d) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობა"`,
                    options: [
                        "a) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობა",
                        "b) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლო",
                        "c) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლოს ტიპი",
                        "d) ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობა"
                    ],
                    correct: 1,
                    explanation: "პარამეტრი არის ფუნქციის გამოძახებისას გადაცემილი მნიშვნელობას აღიარებული სიმბოლო."
                },

                {
                    question:"რა არის ფუნქციის ტიპი?",
                    code: `// რომელია სწორი?
a) ფუნქციის გამოძახების მნიშვნელობა
b) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლო
c) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპი
d) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობა"`,
                    options: [
                        "a) ფუნქციის გამოძახების მნიშვნელობა",
                        "b) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლო",
                        "c) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპი",
                        "d) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობა"
                    ],
                    correct: 2,
                    explanation: "ფუნქციის ტიპი არის ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპი."
                },
                {
                    question:"რა არის არგუმენტის ტიპი?",
                    code: `// რომელია სწორი?
a) ფუნქციის გამოძახების მნიშვნელობა
b) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლო
c) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპი
d) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობა"`,
                    options: [
                        "a) ფუნქციის გამოძახების მნიშვნელობა",
                        "b) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლო",
                        "c) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპი",
                        "d) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობა"
                    ],
                    correct: 2,
                    explanation: "არგუმენტის ტიპი არის ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპი."
                },
                {
                    question:"რას აბრუნებს return statement?",
                    code: `// რომელია სწორი?
a) ფუნქციის გამოძახების მნიშვნელობა
b) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლო
c) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპი
d) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობა"`,
                    options: [
                        "a) ფუნქციის გამოძახების მნიშვნელობა",
                        "b) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლო",
                        "c) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპი",
                        "d) ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობა"
                    ],
                    correct: 3,
                    explanation: "return statement აბრუნებს ფუნქციის გამოძახების მნიშვნელობას აღიარებული სიმბოლოს ტიპის მნიშვნელობას."
                },
                {
                    question:"რა არის JavaScript-ის მთავარი დანიშნულება?",
                    code: `// რომელია სწორი?
a) JavaScript არის statically typed language
b) JavaScript არის dynamically typed language
c) JavaScript არის interpreted language
d) JavaScript არის compiled language`,
                    options: [
                        "a) JavaScript არის statically typed language",
                        "b) JavaScript არის dynamically typed language",
                        "c) JavaScript არის interpreted language",
                        "d) JavaScript არის compiled language"
                    ],
                    correct: 1,
                    explanation: "JavaScript არის dynamically typed language, რაც ნიშნავს, რომ ცვლადების ტიპები არის განსაზღვრული დადგენილებით."
                },
                {
                    question:"რა არის JavaScript-ის შესაძლებლობა, რომელიც TypeScript-ში არ არსებობს?",
                    code: `// რა არის სწორი სინტაქსი?
a) let message: string = 'Hello';
b) let message = 'Hello';
c) var message: string = 'Hello';
d) const message = 'Hello';`,
                    options: [
                        "a) let message: string = 'Hello';",
                        "b) let message = 'Hello';",
                        "c) var message: string = 'Hello';",
                        "d) const message = 'Hello';"
                    ],
                    correct: 1,
                    explanation: "JavaScript-ში არ შეგვიძლია განსაზღვროთ ცვლადის type, რაც არის TypeScript-ის შესაძლებლობა."
                },
                {
                    question: "რა განსხვავებაა JavaScript-ში var-სა და let-ს შორის?",
                    code: `var x = 1;
let y = 2;
{
    var x = 3;
    let y = 4;
    console.log(x, y); // ?
}
console.log(x, y); // ?`,
                    options: [
                        "var ქმნის ფუნქციურ სკოპს, let კი ბლოკურ სკოპს",
                        "let ქმნის ფუნქციურ სკოპს, var კი ბლოკურ სკოპს",
                        "ორივე იდენტურია",
                        "var უფრო სწრაფია let-ზე"
                    ],
                    correct: 0,
                    explanation: "var ქმნის ფუნქციურ ან გლობალურ სკოპს, ხოლო let ქმნის ბლოკურ სკოპს. ამ მაგალითში console.log(x, y) გამოიტანს 3, 4, ხოლო მეორე console.log(x, y) გამოიტანს 3, 2."
                },
                {
                    question: "რას გამოიტანს console.log(typeof null)?",
                    code: `console.log(typeof null);`,
                    options: [
                        '"object"',
                        '"null"',
                        '"undefined"',
                        '"string"'
                    ],
                    correct: 0,
                    explanation: "JavaScript-ში typeof null აბრუნებს 'object', რაც ისტორიული შეცდომაა."
                },
                {
                    question: "რა არის JavaScript-ის ფუნქციის განსაზღვრის სწორი გზა?",
                    code: `// რომელია სწორი?
a) function myFunc() {}
b) var myFunc = function() {}
c) let myFunc = () => {}
d) ყველა სწორია`,
                    options: [
                        "d) ყველა სწორია",
                        "a) მხოლოდ function declaration",
                        "b) მხოლოდ function expression",
                        "c) მხოლოდ arrow function"
                    ],
                    correct: 0,
                    explanation: "JavaScript-ში ფუნქციის განსაზღვრა შესაძლებელია function declaration-ით, function expression-ით, ან arrow function-ით. ყველა ვარიანტი სწორია."
                },
                {
                    question: "რა არის JavaScript-ის მასივის სიგრძის თვისება?",
                    code: `let arr = [1, 2, 3];
console.log(arr.length); // ?`,
                    options: [
                        "3",
                        "2",
                        "4",
                        "undefined"
                    ],
                    correct: 0,
                    explanation: "მასივის length თვისება აბრუნებს ელემენტების რაოდენობას. ამ შემთხვევაში arr.length = 3."
                },
                {
                   question: "როგორ მუშაობს JavaScript-ში == და ===?",
                   code: `console.log(1 == '1'); // ?
console.log(1 === '1'); // ?`,
                   options: [
                        "true, false",
                        "false, true",
                        "true, true",
                        "false, false"
                    ],
                    correct: 0,
                    explanation: "== ახდენს type coercion-ს, ამიტომ 1 == '1' არის true. === ამოწმებს ტიპსაც, ამიტომ 1 === '1' არის false."
                },
                {
                    question: "რა არის JavaScript-ის undefined?",
                    code: `let x;
console.log(x); // ?`,
                    options: [
                        "undefined",
                        "null",
                        "0",
                        "Error"
                    ],
                    correct: 0,
                    explanation: "განუსაზღვრელი ცვლადი JavaScript-ში აბრუნებს undefined."
                },
                {
                    question: "რას გამოიტანს console.log(!!'false')?",
                    code: `console.log(!!'false'); // ?`,
                    options: [
                        "true",
                        "false",
                        "undefined",
                        "Error"
                    ],
                    correct: 0,
                    explanation: "!! გარდაქმნის მნიშვნელობას boolean-ად. 'false' (როგორც არა-ცარიელი სტრიქონი) არის truthy, ამიტომ !!'false' = true."
                },
                {
                    question: "რა არის JavaScript-ის forEach მეთოდის დანიშნულ?",
                    code: `let numbers = [1, 2, 3];
numbers.forEach(num => console.log(num));`,
                    options: [
                        "არის მასივის ელემენტების იტერაციის მეთოდი",
                        "არის მასივის ელემენტების გაფილტვრის მეთოდი",
                        "არის მასივის ელემენტების ამატების მეთოდი",
                        "არის მასივის ელემენტების გამოყოფის მეთოდი"
                    ],
                    correct: 0,
                    explanation: "forEach მეთოდი არის მასივის ელემენტების იტერაციის მეთოდი."
                },
                {
                    question: "რა არის JavaScript-ის შესაძლებლობა, რომელიც TypeScript-ში არ არსებობს?",
                    code: `// რა არის სწორი სინტაქსი?
let message: string = 'Hello';`,
                    options: [  
                        "JavaScript-ში შეგვიძლია განსაზღვროთ ცვლადის type",
                        "JavaScript-ში შეგვიძლია განსაზღვროთ ცვლადის scope",
                        "JavaScript-ში შეგვიძლია განსაზღვროთ ცვლადის value",
                        "JavaScript-ში შეგვიძლია განსაზღვროთ ცვლადის name"
                    ],
                    correct: 0,
                    explanation: "JavaScript-ში არ შეგვიძლია განსაზღვროთ ცვლადის type."
                },
                {
                    question: "რა არის JavaScript-ში var-ისა და let-ის ძირითადი განსხვავება?",
                    code: `var x = 1;
let y = 2;
{
    var x = 3;
    let y = 4;
    console.log(x, y); // ?
}
console.log(x, y); // ?`,
                    options: [
                        "var ქმნის ფუნქციური scoping-ს, let კი block scoping-ს",
                        "let ქმნის ფუნქციური scoping-ს, var კი block scoping-ს",
                        "ორივე იდენტურია",
                        "var უფრო სწრაფია let-ზე"
                    ],
                    correct: 0,
                    explanation: "var ქმნის ფუნქციურ ან გლობალურ scope-ს, ხოლო let ქმნის block scope-ს."
                }
            ],
            jsMedium: [
                {
                    question:"რა არის JavaScript-ის prototype-based inheritance-ის მიზანი?",
                    code: `// რა არის სწორი სინტაქსი?
a) class Person {
    constructor(name) {
        this.name = name;
    }
}
b) function Person(name) {
    this.name = name;
}
Person.prototype.sayHello = function() {
    console.log('Hello, my name is ' + this.name);
}
c) ყველა სწორია
d) არცერთი არასწორია`,
                    options: [
                        "a) class Person { ... }",
                        "b) function Person(name) { ... }",
                        "c) ყველა სწორია",
                        "d) არცერთი არასწორია"
                    ],
                    correct: 2,
                    explanation: "JavaScript-ის prototype-based inheritance-ის მიზანია გამოიყენება სხვა კლასის მიმართ მეთოდების გამოყენებისთვის."
                },
                {
                    question:"რა შედეგს მიიღებთ?",
                    code: `function Person(name) {
    this.name = name;
}
Person.prototype.sayHello = function() {
    console.log('Hello, my name is ' + this.name);
}
const person = new Person('გიორგი');
person.sayHello(); // ?`,
                    options: [
                        "Hello, my name is გიორგი",
                        "Error",
                        "undefined",
                        "Hello, my name is undefined"
                    ],
                    correct: 0,
                    explanation: "ამ მაგალითში არსებითადი კლასი გამოიყენება სხვა კლასის მიმართ მეთოდების გამოყენებისთვის."
                },
                {
                    question:"რა დანიშნულება აქვს ლუპებს?",
                    code: `// რა არის სწორი სინტაქსი?
a) for (let i = 0; i < 10; i++) {}
b) while (i < 10) {}
c) do {} while (i < 10);
d) ყველა სწორია`,
                    options: [
                        "a) for (let i = 0; i < 10; i++) {}",
                        "b) while (i < 10) {}",
                        "c) do {} while (i < 10);",
                        "d) ყველა სწორია"
                    ],
                    correct: 3,
                    explanation: "ლუპები არის სიმრავლეები, რომლებიც გამოიყენება რიცხვის მნიშვნელობის გაზრდისთვის."
                },
                {
                    question:"რა არის რეკურსია?",
                    code: `// რა არის სწორი სინტაქსი?
a) function factorial(n) {
    if (n === 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
b) function factorial(n) {  
                    return n * factorial(n - 1);
}
c) ყველა სწორია
d) არცერთი არასწორია`,
                    options: [
                        "a) function factorial(n) { ... }",
                        "b) function factorial(n) { ... }",
                        "c) ყველა სწორია",
                        "d) არცერთი არასწორია"
                    ],
                    correct: 2,
                    explanation: "რეკურსია არის ფუნქციის გამოძახება იგივე ფუნქციის გარდა."
                },
                {
                    question:"როდის გამოიყენება for loop-ი?",
                    code: `// რა არის სწორი სინტაქსი?
a) for (let i = 0; i < 10; i++) {}
b) while (i < 10) {}
c) do {} while (i < 10);
d) ყველა სწორია`,
                    options: [
                        "a) for (let i = 0; i < 10; i++) {}",
                        "b) while (i < 10) {}",
                        "c) do {} while (i < 10);",
                        "d) ყველა სწორია"
                    ],
                    correct: 0,
                    explanation: "for loop-ი გამოიყენება მაშინ, როცა გვინდა განსაზღვრული რაოდენობის მეთველების გამოსახულებისთვის."
                },
                {
                    question:"როდის გამოიყენება while loop-ი?",
                    code: `// რა არის სწორი სინტაქსი?
a) for (let i = 0; i < 10; i++) {}
b) while (i < 10) {}
c) do {} while (i < 10);
d) ყველა სწორია`,
                    options: [
                        "a) for (let i = 0; i < 10; i++) {}",
                        "b) while (i < 10) {}",
                        "c) do {} while (i < 10);",
                        "d) ყველა სწორია"
                    ],
                    correct: 1,
                    explanation: "while loop-ი გამოიყენება მაშინ, როცა არ იცნობთ სიმრავლის ზომას წინ."
                },
                {
                    question:"როდის გამოიყენება do...while loop-ი?",
                    code: `// რა არის სწორი სინტაქსი?
a) for (let i = 0; i < 10; i++) {}
b) while (i < 10) {}
c) do {} while (i < 10);
d) ყველა სწორია`,
                    options: [
                        "a) for (let i = 0; i < 10; i++) {}",
                        "b) while (i < 10) {}",
                        "c) do {} while (i < 10);",
                        "d) ყველა სწორია"
                    ],
                    correct: 2,
                    explanation: "do...while loop-ი გამოიყენება მაშინ, როცა გვინდა კოდის ამოვიღარება მინიმუმ ერთხელ."
                },
                
                {
                    question:"როდის გამოიყენება loop-ში while ციკლი?",
                    code: `// რა არის სწორი სინტაქსი?
a) for (let i = 0; i < 10; i++) {}
b) while (i < 10) {}
c) do {} while (i < 10);
d) ყველა სწორია`,
                    options: [
                        "a) for (let i = 0; i < 10; i++) {}",
                        "b) while (i < 10) {}",
                        "c) do {} while (i < 10);",
                        "d) ყველა სწორია"
                    ],
                    correct: 1,
                    explanation: "while ციკლი გამოიყენება მაშინ, როცა არ იცნობთ სიმრავლის ზომას წინ."
                },
                {
                    question:`რა არის callback ფუნქცია?`,
                    code:`function doSomething(callback) {
    // რაღაც ლო직ი
    callback();
}
doSomething(function() {
    console.log('Callback function called!');
});`,
                    options: [
                        "ფუნქცია, რომელიც გადაეცემა სხვა ფუნქციას",
                        "ფუნქცია, რომელსაც არ აქვს არგუმენტები",
                        "ფუნქცია, რომელიც არ არის ფუნქცია",
                        "ფუნქცია, რომელიც აბრუნებს null"
                    ],
                    correct: 0,
                    explanation: "Callback function-ი გადაეცემა სხვა ფუნქციას არგუმენტად."
                },
                {
                    question:"რას აკეთებს Promise.resolve(42).then(x => x * 2).then(console.log)?",
                    code:`Promise.resolve(42).then(x => x * 2).then(console.log); // ?`,
                    options:[
                        "84",
                        "42",
                        "Error",
                        "undefined"
                    ],
                    correct: 0,
                    explanation: "Promise.resolve(42) აბრუნებს 42-ს, .then(x => x * 2) ამრავლებს 2-ზე (გამოდის 84), და console.log გამოიტანს 84-ს."
                },
                {
                    question:"რა არის Array.prototype.filter()-ის დანიშნულება?",
                    code:`let arr = [1, 2, 3, 4];
let result = arr.filter(x => x % 2 === 0);
console.log(result); // ?`,
                    options:[
                        "[2, 4]",
                        "[1, 3]",
                        "[1, 2, 3, 4]",
                        "[ შეცდომა]"
                    ],
                    correct: 0,
                    explanation:"filter() აბრუნებს ახალ მასივს, რომელიც შეიცავს ელემენტებს, რომლებიც აკმაყოფილებენ პირობას."
                },
                {
                    question: "რა არის spread ოპერატორი?",
                    code: `let arr1 = [1, 2];
let arr2 = [...arr1, 3];
console.log(arr2); // ?`,
                    options: [
                        "[1, 2, 3]",
                        "[1, 2]",
                        "3",
                        "შეცდომა"
                    ],
                    correct: 0,
                    explanation: "spread ოპერატორი (...) კოპირებს მასივის ელემენტებს ახალ მასივში."
                },
                {
                    question:" რა არის Array.prototype.map()-ის დანიშნულება?",
                    code: `let arr = [1, 2, 3];
let result = arr.map(x => x * 2);
console.log(result); // ?`,
                    options: [
                        "[2, 4, 6]",
                        "[1, 2, 3]",
                        "[1, 4, 9]",
                        "შეცდომა"
                    ],
                    correct: 0,
                    explanation: "map() აბრუნებს ახალ მასივს, რომელიც შეიცავს ელემენტებს, რომლებიც არის ფუნქციის გამოარჩევებით."
                },
                {
                    question:"რა არის Array.prototype.reduce()-ის დანიშნულება?",
                    code: `let arr = [1, 2, 3];
let result = arr.reduce((acc, x) => acc + x, 0);
console.log(result); // ?`,
                    options: [
                        "6",
                        "1",
                        "3",
                        "შეცდომა"
                    ],
                    correct: 0,
                    explanation: "reduce() აბრუნებს ერთ მნიშვნელობას, რომელიც არის არგუმენტების ფუნქციის გამოარჩევებით."    
                },
                {
                    question:"რა არის Array.prototype.forEach()-ის დანიშნულება?",
                    code: `let arr = [1, 2, 3];
arr.forEach(x => console.log(x)); // ?`,
                    options: [
                        "1, 2, 3",
                        "3, 2, 1",
                        "1, 1, 1",
                        "შეცდომა"  
                    ],
                    correct: 0,
                    explanation: "forEach() იტერაციას აკეთებს მასივის ელემენტებზე და არ აბრუნებს მნიშვნელობას." 
                },
                {
                    ქუესტიონ:"რა არის ასინქრონული კოდი?",
                    code: `console.log('1');
setTimeout(() => console.log('2'), 0);
console.log('3'); // ?`,
                    options: [
                        "1, 2, 3",
                        "3, 2, 1",
                        "1, 3, 2",
                        "შეცდომა"
                    ],
                    correct: 2,
                    explanation: "setTimeout არის ასინქრონული ფუნქცია, რომელიც დასრულება მეორე ციკლში."
                },
                {
                    question:"რა არის Promise?",
                    code: `let p = new Promise((resolve, reject) => {
    // რაღაც ლოგიკა
    resolve('მარაგი');
});
p.then(result => console.log(result)); // ?`,
                    options: [
                        "მარაგი",
                        "შეცდომა",
                        "undefined",
                        "null"
                    ],
                    correct: 0,
                    explanation: "Promise არის ასინქრონული კოდის შემდეგ ამოძალური მნიშვნელობა."
                },
                {
                    question:"რა არის async/await?",
                    code: `async function myFunc() {
    return 'მარაგი';
}
myFunc().then(result => console.log(result)); // ?`,
                    options: [
                        "მარაგი",
                        "შეცდომა",
                        "undefined",
                        "null"
                    ],
                    correct: 0,
                    explanation: "async/await არის syntactic sugar Promise-ებისთვის."
                },
                {
                    question:" რა არის AJAX?",
                    code: `// რა არის სწორი?
a) AJAX არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს
b) AJAX არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას არ აძლევს 
c) AJAX არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს მხოლოდ ბრაუზერში
d) AJAX არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს მხოლოდ სერვერზე`,
                    options: [
                        "a) AJAX არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს",         
                        "b) AJAX არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას არ აძლევს",
                        "c) AJAX არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს მხოლოდ ბრაუზერში",
                        "d) AJAX არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს მხოლოდ სერვერზე"
                    ],
                    correct: 0,
                    explanation: "AJAX არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს მხოლოდ ბრაუზერში."
                },
                {
                    question:"რა არის CORS?",
                    code: `// რა არის სწორი?
a) CORS არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს
b) CORS არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას არ აძლევს
c) CORS არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს მხოლოდ ბრაუზერში
d) CORS არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს მხოლოდ სერვერზე`,
                    options: [
                        "a) CORS არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს",
                        "b) CORS არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას არ აძლევს",
                        "c) CORS არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს მხოლოდ ბრაუზერში",
                        "d) CORS არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს მხოლოდ სერვერზე"
                    ],
                    correct: 0,
                    explanation: "CORS არის ტექნიკა, რომელიც ასინქრონული კოდის შესაძლებლობას აძლევს მხოლოდ ბრაუზერში."
                },
            ],
            jsAdvanced: [
                {
                    question:"როდის გამოიყენება if statement-ი?",
                    code: `// რა არის სწორი სინტაქსი?
a) if (i < 10) {}
b) if (i < 10) {} else {}
c) if (i < 10) {} else if (i < 20) {}
d) ყველა სწორია`,
                    options: [
                        "a) if (i < 10) {}",
                        "b) if (i < 10) {} else {}",
                        "c) if (i < 10) {} else if (i < 20) {}",
                        "d) ყველა სწორია"
                    ],
                    correct: 3,
                    explanation: "if statement-ი გამოიყენება მაშინ, როცა გვინდა რამდენიმე პარამეტრის შემოწმება."
                },
                {
                    question:"რა არის დაასკრიბება (hoisting)?",
                    code: `console.log(x); // ?
var x = 5;`,
                    options: [
                        "არის შეცდომა",
                        "არის უცნობი",
                        "არის ნული",
                        "არის undefined"
                    ],
                    correct: 3,
                    explanation: "დაასკრიბება (hoisting) არის პროცესი, რომელიც ასაკნი ცვლადი ან ფუნქცია გადატანილია ფანჯრის წინ და არის მისი მნიშვნელობა უცნობი."
                },
                {
                    question: "რა დაბეჭდება კონსოლში async ფუნქციის შესრულებისას?",
                    code: `
async function test() {
  return "Hello";
}
test().then(console.log);`,
                    options: [
                        "Promise",
                        "Hello",
                        "undefined",
                        "error"
                    ],
                    correct: 1,
                    explanation: "async ფუნქცია ყოველთვის აბრუნებს Promise-ს, ხოლო `then(console.log)` ბეჭდავს ამ Promise-ის რეზულტატს — 'Hello'."
                },
                {
                    question: "რა გააკეთებს ეს კოდი HTML-ში?",
                    code: `
document.getElementById("title").innerText = "Welcome!";`,
                    options: [
                        "შეცვლის ელემენტის სტილს",
                        "შეცვლის ელემენტის ტექსტს",
                        "წაშლის ელემენტს",
                        "შექმნის ახალ ელემენტს"
                    ],
                    correct: 1,
                    explanation: "`innerText` ატრიბუტი ცვლის DOM ელემენტის ტექსტურ შინაარსს. ამ შემთხვევაში — 'Welcome!'."
                },
                {
                    question: "რა არის ეს კოდი?",
                    code: `
const person = {
  name: "John",
  age: 30
};
const { name, age } = person;"`,
                    options: [
                        "არის არსებული ელემენტის მიმართვა",
                        "არის არსებული ელემენტის წაშლა",
                        "არის არსებული ელემენტის შექმნა",
                        "არის არსებული ელემენტის ატრიბუტების ამატება"
                    ],
                    correct: 3,
                    explanation: "ამ კოდში გამოიყენება დესტრუქტურირება, რომელიც ატრიბუტების ამატებას აღწერს."
                },
                {
                    question:"რა არის Indexed Access Types?",
                    code:`interface User {
    name: string;
    age: number;
}
type UserName = User['name'];`,
                    options:[
                        "არის ტიპის აღწერა",
                        "არის სიტყვის აღწერა",
                        "არის მასივის აღწერა",
                        "არის ინტერფეისის ან ტიპის properties-ების ტიპის აღწერა"
                    ],
                    correct:3,
                    explanation:"Indexed Access Types აღწერს ინტერფეისის ან ტიპის properties-ების ტიპს."
                },
                {
                    question:"რა არის ტიპის მომართვა (type assertion)?",
                    code:`let x: any = "hello";
let strLength: number = (x as string).length;`,
                    options:[
                        "არის ტიპის განსაზღვრა",        
                        "არის სიტყვის აღწერა",
                        "არის მასივის აღწერა",
                        "არის ტიპის მომართვა"
                    ],
                    correct:3,
                    explanation:"ტიპის მომართვა არის საშუალება, რომელიც საშუალებას იძლევა დეველოპერმა TypeScript-ს უთხრათ ცვლადის type."
                },
                {
                    question:"რა არის დახურვა (closure)?",
                    code:`function outerFunction(x) {
    return function innerFunction(y) {
        return x + y;
        };
}
const addFive = outerFunction(5);
console.log(addFive(3)); // ?`,
                    options:[
                        "8 - დახურვა ინარჩუნებს გარე სკოპის ცვლადებს",
                        "შეცდომა - x განუსაზღვრელია",
                        "undefined",
                        "3"
                    ],
                    correcr:0,
                    explanation:"დახურვა საშუალებას აძლევს შიდა ფუნქციას წვდომა ჰქონდეს გარე ფუნქციის ცვლადებზე."
                },
                {
                    question:"რა არის მოვლენების ციკლი (event loop)?",
                    code:`console.log('1');
setTimeout(() => console.log('2'), 0);
Promise.resolve().then(() => console.log('3'));
console.log('4'); // ?`,
                    options:[
                        "1, 4, 3, 2",
                        "1, 2, 4, 3",
                        "1, 3, 4, 2",
                        "2, 3, 4, 1"
                    ],
                    correct:2,
                    explanation: "მოვლენების ციკლი ჯერ ასრულებს სინქრონულ კოდს (1, 4), შემდეგ მიკროდავალებებს (3), და ბოლოს მაკროდავალებებს (2)."
                },
                {
                    question:" რას აკეთებს Object.create(null)?",
                    code:`let obj = Object.create(null);
console.log(obj.__proto__); // ?`,
                    options: [
                        "undefined",
                        "{}",
                        "Object.prototype",
                        "null"
                    ],
                    correct:3,
                    explanation: "Object.create(null) ქმნის ობიექტს პროტოტიპის გარეშე."
                 },
                 {
                    question:"რა არის ასინქრონული კოდი?",
                    code:`console.log('1');
setTimeout(() => console.log('2'), 0);
console.log('3'); // ?`,
                    options: [
                        "1, 2, 3",
                        "1, 3, 2",
                        "2, 1, 3",
                        "3, 1, 2"
                    ],
                    correct:1,
                    explanation: "setTimeout არის ასინქრონული ფუნქცია, რომელიც დასრულება მეორე ციკლში."
                 },
                 {
                    question:"რა არის გენერატორის ფუნქცია?",
                    code:`function* myGen() {
    yield 1;
    yield 2;
}
const gen = myGen();
console.log(gen.next()); // ?`,
                    options:[
                        "{ value: 1, done: false }",
                        "1",
                        "{ value: 2, done: false }",
                        "შეცდომა"
                    ],
                    correct:0,
                    explanation: "გენერატორი აბრუნებს მნიშვნელობებს ერთჯერადად, next() აბრუნებს { value, done } ობიექტს."
                 },
                 {
                    question:"რა არის ES6-ის Symbol-ის დანიშნულება?",
                    code:`const sym = Symbol('id');
let obj = { [sym]: 42 };
console.log(obj[sym]); // ?`,
                    options:[
                        "42",
                        "undefined",
                        "Error",
                        "Symbol('id')"
                    ],
                    correct:0,
                    explanation: "Symbol-ები უნიკალური მნიშვნელობებია, რომლებიც გამოიყენება ობიექტის unique property-ების შესაქმნელად."
                 },
                 {
                    question:"რას აკეთებს Array.prototype.flat()?",
                    code:`let arr = [1, [2, [3]]];
console.log(arr.flat()); // ?`,
                    options:[
                        "[1, 2, [3]]",
                        "[1, 2, 3]",
                        "[1, [2, 3]]",
                        "შეცდომა"
                    ],
                    correct:2,
                    explanation: "flat() ამოიღებს მასივიდან შეშრობულ ელემენტებს და აბრუნებს ახალ მასივს."
                 },
                 {
                    question:"რა არის Proxy JavaScript-ში?",
                    code:`let target = { a: 1 };
let handler = { get(target, prop) { return target[prop] * 2; } };
let proxy = new Proxy(target, handler);
console.log(proxy.a); // ?`,
                    options:[
                        "2",
                        "1",
                        "undefined",
                        "Error"
                    ],
                    correct:0,  
                    explanation: "Proxy საშუალებას გაძლევთ გააკონტროლოთ ობიექტის ოპერაციები, მაგ. თვისებებზე წვდომა."
                 },
                 {
                    question:"რას აკეთებს Reflect.getOwnPropertyDescriptor?",
                    code:`let obj = { a: 42 };
let desc = Reflect.getOwnPropertyDescriptor(obj, 'a');
console.log(desc.value); // ?`,
                    options:[
                        "42",
                        "undefined",
                        "Error",
                        "null"
                    ],
                    correct:0,
                    explanation: "Reflect.getOwnPropertyDescriptor აბრუნებს ობიექტის თვისების აღწერას."
                 },
                 {
                    question:" რა აკეთებს Object.assign?",
                    code:`let target = { a: 1 };
let source = { b: 2 };
let result = Object.assign(target, source);
console.log(result); // ?`,
                    options:[
                        "{ a: 1, b: 2 }",
                        "{ b: 2 }",
                        "{ a: 1 }",
                        "შეცდომა"
                    ],
                    correct:0,
                    explanation: "Object.assign აკოპირებს ერთი არგუმენტიდან მეორეში."
                 },
                 {
                    question:" რას აკეთებს Object.freeze?",
                    code:`let obj = { a: 1 };
Object.freeze(obj);
obj.a = 2;
console.log(obj.a); // ?`,
                    options:[
                        "2",
                        "1",
                        "undefined",
                        "Error"
                    ],
                    correct:3,
                    explanation: "Object.freeze არ არის writable და არ არის configurable."
                 },
                 {
                    question:"რა დანიშნულება აქვს Typescript-ს?",
                    code:`// რა არის სწორი სინტაქსი?
a) let message: string = 'Hello';
b) let message = 'Hello';
c) var message: string = 'Hello';
d) const message = 'Hello';`,
                    options:[
                        "a) let message: string = 'Hello';",
                        "b) let message = 'Hello';",
                        "c) var message: string = 'Hello';",
                        "d) const message = 'Hello';"
                    ],
                    correct:0,
                    explanation: "Typescript-ში შეგვიძლია განსაზღვროთ ცვლადის type."
                 },
                {
                    question: "რა არის closure?",
                    code: `function outerFunction(x) {
    return function innerFunction(y) {
        return x + y;
    };
}
const addFive = outerFunction(5);
console.log(addFive(3)); // ?`,
                    options: [
                        "8 - closure ინახავს outer scope-ის ცვლადებს",
                        "Error - x არ არის განსაზღვრული",
                        "undefined",
                        "3"
                    ],
                    correct: 0,
                    explanation: "Closure საშუალებას აძლევს შიდა ფუნქციას შეინახოს გარე ფუნქციის ცვლადები."
                }
            ],
            tsBeginner: [

                {
                    question: "რა არის TypeScript-ის მთავარი დანიშნულება?",
                    code:`let message: string = 'გამარჯობა';
message = 42; // შეცდომა`,
                    options:[
                        "TypeScript არის statically typed language",
                        "TypeScript არის dynamically typed language",
                        "TypeScript არის interpreted language",
                        "TypeScript არის compiled language"
                    ],
                    correct: 0,
                    explanation: "TypeScript არის statically typed language, რაც ნიშნავს, რომ ცვლადების ტიპები არის განსაზღვრული დადგენილებით."
                },
                {
                    question:"რა არის interface?",
                    code:`interface Person {
    name: string;
    age: number;
}
let person: Person = {
    name: 'გიო',
    age: 30
};`,
                    options:[
                        "ობიექტისთვის მონაცემთა შესაზღვრად",
                        "ერთი კლასისთვის მონაცემთა შესაზღვრად",
                        "მასივისთვის მონაცემთა შესაზღვრად",
                        "არაა მხარდაჭერილი"
                    ],
                    correct:0,
                    explanation: "ინტერფეისი განსაზღვრავს არსებითადი კლასის ან ფუნქციის სინტაქსის გზას."
                },
                {
                    question:"რა არის TypeScript-ში class?",
                    code:`class Person {
    name: string;
    age: number;
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
}
let person = new Person('გიო', 30);`,
                    options:[
                        "ობიექტისთვის მონაცემთა შესაზღვრად",
                        "ერთი კლასისთვის მონაცემთა შესაზღვრად",
                        "მასივისთვის მონაცემთა შესაზღვრად",
                        "არაა მხარდაჭერილი"
                    ],
                    correct:1,
                    explanation: "კლასი განსაზღვრავს ერთი კლასისთვის მონაცემთა შესაზღვრად."
                },
                {
                    question:"რა არის TypeScript-ში enum?",
                    code:`enum Color {
    Red,
    Green,
    Blue
}
let color: Color = Color.Red;`,
                    options:[
                        "მნიშვნელობის განსაზღვრა",
                        "მნიშვნელობის განსაზღვრა მასივში",
                        "მნიშვნელობის განსაზღვრა არსებითად კლასში",
                        "არაა მხარდაჭერილი"
                    ],
                    correct:0,
                    explanation: "ენამი არის მნიშვნელობების სია, რომლებიც მიიღებენ ავტომატურად მნიშვნელობებს."
                },
                {
                    question:"რა არის TypeScript-ში გენერიკული ტიპი?",
                    code:`function identity<T>(arg: T): T {
    return arg;
}
let x = identity(42); // x არის number-ის ტიპი`,
                    options:[
                        "ტიპის განსაზღვრა ნებისმიერი ტიპისთვის",
                        "მნიშვნელობის განსაზღვრა მასივში",
                        "მნიშვნელობის განსაზღვრა არსებითად კლასში",
                        "არაა მხარდაჭერილი"
                    ],
                    correct:0,
                    explanation: "გენერიკული ტიპი არის ტიპი, რომლებიც შეიძლება იყოს ნებისმიერი ტიპი."
                },
                {
                    question:"რა არის TypeScript-ში მომართვა (type assertion)?",
                    code:`let x: any = "გამარჯობა";
let len: number = (x as string).length;`,
                    options:[
                        "ტიპის განსაზღვრა სინტაქსით",
                        "მნიშვნელობის განსაზღვრა მასივში",
                        "მნიშვნელობის განსაზღვრა არსებითად კლასში",
                        "არაა მხარდაჭერილი"
                    ],
                    correct:0,
                    explanation: "ტიპის მომართვა არის საშუალება, რომელიც საშუალებას იძლევა დეველოპერმა TypeScript-ს უთხრათ ცვლადის type."
                },
                {
                    question:"რა არის TypeScript-ში განსაზღვრების შეზღუდვა?",
                    code:`function log<T extends { name: string }>(obj: T) {
    console.log(obj.name);
}`,
                    options:[
                        "ტიპის განსაზღვრა სინტაქსით",
                        "მნიშვნელობის განსაზღვრა მასივში",
                        "მნიშვნელობის განსაზღვრა არსებითად კლასში",
                        "არაა მხარდაჭერილი"
                    ],
                    correct:0,
                    explanation: "განსაზღვრების შეზღუდვა არის ტიპის განსაზღვრა, რომელიც შეიძლება იყოს ნებისმიერი ტიპი."
                },
                {
                    question:"რა არის TypeScript-ში სინტაქსის აღწერა?",
                    code:`type Point = { x: number; y: number };
let p: Point = { x: 1, y: 2 };`,
                    options:[
                        "ტიპის განსაზღვრა სინტაქსით",
                        "მნიშვნელობის განსაზღვრა მასივში",
                        "მნიშვნელობის განსაზღვრა არსებითად კლასში",
                        "არაა მხარდაჭერილი"
                    ],
                    correct:0,
                    explanation: "სინტაქსის აღწერა არის ტიპის განსაზღვრა სინტაქსით."
                },
                {
                    question:"რას აკეთებს Function-ის გამოყენება?",
                    code:`function add(x: number, y: number): number {
    return x + y;
}
let sum: number = add(1, 2);`,
                    options:[
                        "ფუნქციის განსაზღვრა",
                        "მნიშვნელობის განსაზღვრა მასივში",
                        "მნიშვნელობის განსაზღვრა არსებითად კლასში",
                        "არაა მხარდაჭერილი"
                    ],
                    correct:0,
                    explanation: "Function-ის გამოყენება არის ფუნქციის განსაზღვრა."
                },
                {
                    question:"რა არის გაერთიანების ტიპი (union type)?",
                    code:`let x: number | string;
x = 42; // OK
x = "გამარჯობა"; // OK
x = true; // შეცდომა`,
                    options:[
                        "ცვლადისთვის მრავალი ტიპის ნებართვა",
                        "ერთი ტიპის შეზღუდვა",
                        "მხოლოდ ობიექტებისთვის",
                        "არაა მხარდაჭერილი"
                    ],
                    correct:0,
                    explanation: "გაერთიანების ტიპი საშუალებას აძლევს ცვლადს ჰქონდეს რამდენიმე ტიპი."
                },
                {
                    question:"რა არის TypeScript-ის შესაძლებლობა, რომელიც JavaScript-ში არ არსებობს?",
                    code:`let message: string = 'Hello';
message = 42; // შეცდომა`,
                    options:[
                        "TypeScript-ში შეგვიძლია განსაზღვროთ ცვლადის type",
                        "TypeScript-ში შეგვიძლია განსაზღვროთ ცვლადის scope",
                        "TypeScript-ში შეგვიძლია განსაზღვროთ ცვლადის value",
                        "TypeScript-ში შეგვიძლია განსაზღვროთ ცვლადის name"
                    ],
                    correct: 0,
                    explanation: "TypeScript-ში შეგვიძლია განსაზღვროთ ცვლადის type, რაც  JavaScript-ში არ არსებობს."
                },
                {
                    question:"რა არის ინტერფეისი TypeScript-ში?",
                    code:`interface Person {
    name: string;
}
let person: Person = { name: "ანა" };`,
                    options:[
                        "ობიექტის სტრუქტურის განსაზღვრის კონტრაქტი",
                        "კლასის ჩანაცვლება",
                        "გაშვების დროის ტიპის შემოწმება",
                        "JavaScript ობიექტი"
                    ],
                    correct: 0,
                    explanation: "ინტერფეისი განსაზღვრავს არსებითადი კლასის ან ფუნქციის სინტაქსის გზას."
                },
                {
                    question:"რას აკეთებს any ტიპი?",
                    code:`let x: any;
x = 42;
x = "გამარჯობა"; // შეცდომა არაა`,
                    options:[
                        "გამორთავს ტიპის შემოწმებას",
                        "აძლიერებს მკაცრ ტიპიზაციას",
                        "მხოლოდ პრიმიტივებს ნებადართავს",
                        "აგდებს შეცდომებს"
                    ],
                    correct:0,
                    explanation:"any ტიპი ნებადართავს ნებისმიერ მნიშვნელობას, გვერდს უვლის ტიპის შემოწმებას."
                },
                {
                    question:"როგორ განისაზღვრება ფუნქციის ტიპი TypeScript-ში?",
                    code:`let add: (a: number, b: number) => number;
add = function(x: number, y: number): number { return x + y; };`,
                    options:[
                        "განსაზღვრება ფუნქციის პარამეტრების და რეტურნის ტიპების საშუალებით",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "ფუნქციის ტიპი განსაზღვრება შეიძლება განსაზღვრავი სინტაქსით."
                },
                {
                    question: "რა არის TypeScript-ის ძირითადი მიზანი?",
                    code: `let message: string = 'Hello';
message = 42; // შეცდომა`,
                    options: [
                        "JavaScript-ში static typing-ის დამატება",
                        "JavaScript-ის შეცვლა",
                        "ახალი პროგრამირების ენის შექმნა",
                        "მხოლოდ transpilation"
                    ],
                    correct: 0,
                    explanation: "TypeScript ამატებს static typing-ს JavaScript-ში."
                },
                {
                    question: "რა არის TypeScript-ის შესაძლებლობა, რომელიც JavaScript-ში არ არსებობს?",
                    code: `// რა არის სწორი სინტაქსი?
a) let message: string = 'Hello';
b) let message = 'Hello';
c) var message: string = 'Hello';
d) const message = 'Hello';`,
                    options: [
                        "a) let message: string = 'Hello';",
                        "b) let message = 'Hello';",
                        "c) var message: string = 'Hello';",
                        "d) const message = 'Hello';"
                    ],
                    correct: 0,
                    explanation: "TypeScript-ში შეგვიძლია განსაზღვროთ ცვლადის type, რაც  JavaScript-ში არ არსებობს."
                },
                {
                    question:"რა არის ინტერფეისი TypeScript-ში?",
                    code:`interface Person {
    name: string;
}
let person: Person = { name: "ანა" };`,
                    options:[
                        "ობიექტის სტრუქტურის განსაზღვრის კონტრაქტი",
                        "კლასის ჩანაცვლება",
                        "გაშვების დროის ტიპის შემოწმება",
                        "JavaScript ობიექტი"
                    ],
                    correct: 0,
                    explanation: "ინტერფეისი განსაზღვრავს არსებითადი კლასის ან ფუნქციის სინტაქსის გზას."
                },
                {
                    question:"რას აკეთებს any ტიპი?",
                    code:`let x: any;
x = 42;
x = "გამარჯობა"; // შეცდომა არაა`,
                    options:[
                        "გამორთავს ტიპის შემოწმებას",           
                        "აძლიერებს მკაცრ ტიპიზაციას",
                        "მხოლოდ პრიმიტივებს ნებადართავს",
                        "აგდებს შეცდომებს"
                    ],
                    correct:0,
                    explanation:"any ტიპი ნებადართავს ნებისმიერ მნიშვნელობას, გვერდს უვლის ტიპის შემოწმებას."
                },
                {
                    question:"რა არის უცნობი ტიპი?",
                    code:`let x: unknown;
x = 42;
x = "გამარჯობა"; // OK
console.log(x.toUpperCase()); // შეცდომა`,
                    options:[   
                        "ნებადართავს ნებისმიერ მნიშვნელობას, გვერდს უვლის ტიპის შემოწმებას",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არსებობს",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "უცნობი ტიპი ნებადართავს ნებისმიერ მნიშვნელობას, მაგრამ გვერდს უვლის ტიპის შემოწმებას."
                },
                {
                    question:"რა არის ტიპის აღწერა?",
                    code:`type Point = { x: number; y: number };
let p: Point = { x: 1, y: 2 };`,
                    options:[
                        "აღწერს ტიპს სინტაქსით",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "ტიპის აღწერა არის ტიპის განსაზღვრა სინტაქსით."
                },
            ],
            tsMedium: [
                {
                    question: "რა არის გენერიკული ტიპები?",
                    code:`function identity<T>(arg: T): T {
    return arg;
}
let x = identity(42); // x არის number-ის ტიპი`,
                    options:[
                        "განსაზღვრავს ფუნქციის პარამეტრების და რეტურნის ტიპებს",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "გენერიკული ტიპები არის ტიპები, რომლებიც შეიძლება იყოს ნებისმიერი ტიპი."
                },
                {
                    question: "რა ტიპი ექნება ფუნქციის დაბრუნებულ მნიშვნელობას?",
                    code: `
async function fetchData(): Promise<string> {
  return "Data";
}`,
                    options: [
                        "string",
                        "Promise<string>",
                        "void",
                        "any"
                    ],
                    correct: 1,
                    explanation: "`async` ფუნქცია TypeScript-ში ყოველთვის აბრუნებს `Promise<T>` ტიპს, სადაც T არის დაბრუნებული ტიპი — აქ `string`."
                },
                {
                    question: "რა არის ინტერფეისი?",
                    code:`interface Person {
    name: string;
    age: number;
}
let person: Person = { name: "ანა", age: 25 };`,
                    options:[
                        "არსებითადი კლასის ან ფუნქციის სინტაქსის გზას განსაზღვრავს",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "ინტერფეისი განსაზღვრავს არსებითადი კლასის ან ფუნქციის სინტაქსის გზას."
                },
                {
                    question: "რა არის keyof მნიშვნელობის ტიპებთან?",
                    code:`interface User {
    name: string;
    age: number;
}
type UserKeys = keyof User; // "name" | "age"`,
                    options:[
                        "აღწერს ინტერფეისის ან ტიპის properties-ებს",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "keyof operator აღწერს ინტერფეისის ან ტიპის properties-ებს."
                },
                {
                    question:" რამდენი სახის ტიპი არის TypeScript-ში?",
                    code:``,
                    options:[
                        "7",
                        "5",
                        "3",
                        "1"
                    ],
                    correct: 0,
                    explanation: "TypeScript-ში არსებობს 7 სახის ტიპი: any, unknown, never, void, number, string, boolean."
                },
                {
                    question:" რომელი არის ტიპის აღწერის სიმბოლო?",
                    code:``,
                    options:[
                        "type",
                        "interface",
                        "class",
                        "enum"
                    ],
                    correct: 0,
                    explanation: "ტიპის აღწერის სიმბოლოა type."
                },
                {
                    question:" რამდენი სახის პრიმიტიული ტიპი არის TypeScript-ში?",
                    code:``,
                    options:[
                        "3",
                        "4",
                        "5",
                        "6"
                    ],
                    correct: 0,
                    explanation: "TypeScript-ში არსებობს 3 სახის პრიმიტიული ტიპი: number, string, boolean."
                },
                {
                    question: "რა არის ტიპის მომართვა (type assertion)?",
                    code:`let x: any = "გამარჯობა";
let len: number = (x as string).length;`,
                    options:[
                        "განსაზღვრავს ტიპს სინტაქსით",  
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "ტიპის მომართვა არის საშუალება, რომელიც საშუალებას იძლევა დეველოპერმა TypeScript-ს უთხრათ ცვლადის type."
                },
                {
                    question:"რა არის ინტერსექცია?",
                    code:`type A = { a: number };
type B = { b: string };
type C = A & B;
let x: C = { a: 1, b: "გამარჯობა" };"`,
                    options:[
                        "შეამცირებს ტიპს ინტერსექციის მიხედვით",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "ინტერსექცია შეამცირებს ტიპს ინტერსექციის მიხედვით."
                },
                {
                    question:"რა არის რეკურსიული ტიპები?",
                    code:`interface Node {
    value: number;
    next?: Node;
}
let node: Node = { value: 1, next: { value: 2, next: { value: 3 } } };`,
                    options:[
                        "აღწერს რეკურსიულ სტრუქტურებს",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "რეკურსიული ტიპები აღწერს რეკურსიულ სტრუქტურებს."
                },
                {
                    question: "რა არის ინტერფეისი?",
                    code:`interface Person {
    name: string;
    age: number;
}
let person: Person = { name: "ანა", age: 25 };`,
                    options:[
                        "არსებითადი კლასის ან ფუნქციის სინტაქსის გზას განსაზღვრავს",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "ინტერფეისი განსაზღვრავს არსებითადი კლასის ან ფუნქციის სინტაქსის გზას."
                },
                {
                    question: "რა არის ენამები?",
                    code:`enum Color {
    Red,
    Green,
    Blue
}
let c: Color = Color.Green;`,
                    options:[
                        "მნიშვნელობების სიას განსაზღვრავს",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "ენამი არის მნიშვნელობების სია, რომლებიც მიიღებენ ავტომატურად მნიშვნელობებს."
                },
                {
                    question: "რა არის ტიპის მომართვა (type assertion)?",
                    code:`let x: any = "გამარჯობა";
let len: number = (x as string).length;`,
                    options:[
                        "განსაზღვრავს ტიპს სინტაქსით",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "ტიპის მომართვა არის საშუალება, რომელიც საშუალებას იძლევა დეველოპერმა TypeScript-ს უთხრათ ცვლადის type."
                },
                {
                    question: "რა არის ტიპის დაცვა (Type Guards)?",
                    code:`function isString(value: any): value is string {
    return typeof value === 'string';
}
let x: unknown;
if (isString(x)) {
    console.log(x.toUpperCase()); // OK
}`,
                    options:[
                        "ამოწმებს ტიპს გაშვების დროს",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "ტიპის დაცვა ამცირებს ტიპს გაშვების დროს შემოწმებით, მაგ. typeof."
                },
                {
                    question: "რა არის განმარჩევი გაერთიანება (discriminated union)?",
                    code:`interface Circle {
    kind: "circle";
    radius: number;
}
interface Square {
    kind: "square";
    side: number;
}
type Shape = Circle | Square;
function getArea(shape: Shape): number {
    switch (shape.kind) {
        case "circle": return Math.PI * shape.radius ** 2;
        case "square": return shape.side ** 2;
    }
}`,
                    options:[
                        "იყენებს ლიტერალს გაერთიანების განსარჩევად",
                        "მხოლოდ კლასებისთვის",
                        "არაა მხარდაჭერილი",
                        "ჩაანაცვლებს ინტერფეისებს"
                    ],
                    correct: 0,
                    explanation: "განმარჩევი გაერთიანება იყენებს საერთო თვისებას ტიპის შესამცირებლად."
                },
                {
                    question: "რა არის გარდაქმნილი ტიპი (mapped type)?",
                    code:`type Readonly<T> = {
    readonly [K in keyof T]: T[K];
};
interface User {
    name: string;
    age: number;
}
type ReadonlyUser = Readonly<User>;`,
                    options:[
                        "გარდაქმნის ტიპის თვისებებს",
                        "ქმნის მასივებს",
                        "მხოლოდ გაერთიანებებისთვის",
                        "არაა მხარდაჭერილი"
                    ],
                    correct: 0,
                    explanation: "გარდაქმნილი ტიპი არის ახალი ტიპი, რომელიც შეიქმნა არსებული ტიპის გარდაქმნით."
                },
                {
                    question:"რა არის ტიპის შემცირება in ოპერატორით?",
                    code:`interface User {
    name: string;
    age?: number;
}
function showUser(user: User) {
    if ('age' in user) {
        console.log(user.age); // OK
    }
}`,
                    options:[
                        "ამოწმებს თვისების არსებობას",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",             
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "in operator ამოწმებს თვისების არსებობას ობიექტში."
                },
                {
                    question: "რა არის გადაკვეთის ტიპი (intersection type)?",
                    code:`type A = { a: number };
type B = { b: string };
type C = A & B;
let x: C = { a: 1, b: "გამარჯობა" };`,
                    options: [
                         "აერთიანებს რამდენიმე ტიპს",
                         "გამორიცხავს თვისებებს",
                         "მხოლოდ გაერთიანებებისთვის",
                         "არაა მხარდაჭერილი"
                        ],
                    correct: 0,
                    explanation: "გადაკვეთის ტიპი აერთიანებს მრავალი ტიპის თვისებებს."
                },
                {
                    question:"რა არის გენერიკული შეზღუდვა?",
                    code:`function getLength<T extends { length: number }>(obj: T): number {
    return obj.length;
}
console.log(getLength([1, 2])); // OK
console.log(getLength(42)); // შეცდომა`,
                     options:[
                        "განსაზღვრავს ფუნქციის პარამეტრის ტიპს",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",     
                        "არ მუშაობს JavaScript-ში"
                    ],
                     correct: 0,
                     explanation: "გენერიკული შეზღუდვა არის ფუნქციის პარამეტრის ტიპის განსაზღვრა, რომელიც შეიძლება იყოს ნებისმიერი ტიპი."
                },
                {
                    question: "რა არის Type Guards?",
                    code: `function isString(value: any): value is string {
    return typeof value === 'string';
}`,
                    options: [
                        "Type Guards საშუალებას იძლევა ცვლადის type-ის შემოწმებას",
                        "Type Guards იყენება მხოლოდ arrays-თან",
                        "Type Guards არ არის TypeScript-ის ნაწილი",
                        "Type Guards არ არსებობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "Type Guards საშუალებას აძლევს TypeScript-ს შეამოწმოს ცვლადის ტიპი runtime-ზე."
                }
            ],
            tsAdvanced: [
                {
                    question: "რა არის keyof operator?",
                    code: `interface User {
    name: string;
    age: number;
}
type UserKeys = keyof User; // 'name' | 'age'`,
                    options: [
                        "keyof operator აღწერს ინტერფეისის ან ტიპის properties-ებს",
                        "keyof operator მხოლოდ arrays-თან მუშაობს",
                        "keyof operator არ არის TypeScript-ის ნაწილი",
                        "keyof operator არ არსებობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "keyof operator აღწერს ინტერფეისის ან ტიპის properties-ებს."
                },
                {
                    question: "რა არის Conditional Types?",
                    code: `type ApiResponse<T> = T extends string
    ? { message: T }
    : { data: T };
type Success = ApiResponse<string>; // { message: string }
type Error = ApiResponse<number>; // { data: number }`,
                    options: [
                        "Conditional Types აღწერს type-ის განსაზღვრა condition-ის მიხედვით",
                        "Conditional Types მხოლოდ arrays-თან მუშაობს",
                        "Conditional Types არ არის TypeScript-ის ნაწილი",
                        "Conditional Types არ არსებობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "Conditional Types აღწერს type-ის განსაზღვრა condition-ის მიხედვით."
                },
                {
                    question: "რა არის Template Literal Types?",
                    code: `type Greeting = "გამარჯობა" | "მოგესალმები";
type Message = \`\${Greeting} სამყარო\`;
let msg: Message = "გამარჯობა სამყარო"; // OK`,
                    options: [
                        "Template Literal Types აღწერს string literal types-ის კომბინირებას",
                        "Template Literal Types მხოლოდ arrays-თან მუშაობს",
                        "Template Literal Types არ არის TypeScript-ის ნაწილი",
                        "Template Literal Types არ არსებობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "Template Literal Types აღწერს string literal types-ის კომბინირებას."
                },
                {
                    question: "რა არის Mapped Types?",
                    code: `type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};

interface User {
    name: string;
    age: number;
}

type ReadonlyUser = Readonly<User>;
// { readonly name: string; readonly age: number; }`,
                    options: [
                        "Mapped Types აღწერს ახალი ტიპის შექმნა არსებული ტიპის გარდაქმნით",
                        "Mapped Types მხოლოდ arrays-თან მუშაობს",
                        "Mapped Types არ არის TypeScript-ის ნაწილი",
                        "Mapped Types არ არსებობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "Mapped Types აღწერს ახალი ტიპის შექმნა არსებული ტიპის გარდაქმნით."
                },
                {
                    question: "რა არის Declaration Merging?",
                    code: `interface User {
    name: string;
}

interface User {
    age: number;
}

let user: User = {
    name: "ანა",
    age: 25
};`,
                    options: [
                        "Declaration Merging აერთიანებს იგივე სახელის რამდენიმე declaration-ს",
                        "Declaration Merging იყენება მხოლოდ arrays-თან",
                        "Declaration Merging არ არის TypeScript-ის ნაწილი",
                        "Declaration Merging არ არსებობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "Declaration Merging აერთიანებს იგივე სახელის რამდენიმე declaration-ს."
                },
                {
                    question: "რა არის Intersection Types?",
                    code: `interface User {
    name: string;
}

interface Admin {
    role: string;
}

type UserAdmin = User & Admin;

let userAdmin: UserAdmin = {
    name: "ანა",
    role: "ადმინისტრატორი"
};`,
                    options: [
                        "Intersection Types აერთიანებს რამდენიმე ტიპს",
                        "Intersection Types მხოლოდ arrays-თან მუშაობს",
                        "Intersection Types არ არის TypeScript-ის ნაწილი",
                        "Intersection Types არ არსებობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "Intersection Types აერთიანებს რამდენიმე ტიპს."
                },
                {
                    question: "რა არის Union Types?",
                    code: `type A = { a: number };
type B = { b: string };
type C = A | B;
let x: C = { a: 1 }; // OK
let y: C = { b: "გამარჯობა" }; // OK`,
                    options: [
                        "Union Types აღწერს რამდენიმე ტიპის გაერთიანებას",
                        "Union Types მხოლოდ arrays-თან მუშაობს",
                        "Union Types არ არის TypeScript-ის ნაწილი",
                        "Union Types არ არსებობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "Union Types აღწერს რამდენიმე ტიპის გაერთიანებას."
                },
                {
                    question: "რა არის Literal Types?",
                    code: `let x: "ანა" = "ანა"; // OK
let y: "ანა" = "ბერნარდი"; // Error`,
                    options: [
                        "Literal Types აღწერს მნიშვნელობის ტიპს",
                        "Literal Types მხოლოდ arrays-თან მუშაობს",
                        "Literal Types არ არის TypeScript-ის ნაწილი",
                        "Literal Types არ არსებობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "Literal Types აღწერს მნიშვნელობის ტიპს."
                },
                {
                    question: "რა არის Tuple Types?",
                    code: `let x: [string, number] = ["ანა", 25]; // OK
let y: [string, number] = [25, "ანა"]; // Error`,
                    options: [
                        "Tuple Types აღწერს მასივის ტიპს",
                        "Tuple Types მხოლოდ arrays-თან მუშაობს",
                        "Tuple Types არ არის TypeScript-ის ნაწილი",
                        "Tuple Types არ არსებობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "Tuple Types აღწერს მასივის ტიპს."
                },
                {
                    question: "რა არის Indexed Access Types?",
                    code: `interface User {
    name: string;
    age: number;
}
type UserName = User['name']; // string`,
                    options: [
                        "Indexed Access Types აღწერს ინტერფეისის ან ტიპის properties-ების ტიპს",
                        "Indexed Access Types მხოლოდ arrays-თან მუშაობს",
                        "Indexed Access Types არ არის TypeScript-ის ნაწილი",
                        "Indexed Access Types არ არსებობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "Indexed Access Types აღწერს ინტერფეისის ან ტიპის properties-ების ტიპს."
                },
                {
                    question: "რა არის Structural Typing?",
                    code: `interface Person {
    name: string;
}
let person = { name: "ანა", age: 25 };
let p: Person = person; // OK`,
                    options: [
                        "Structural Typing ამოწმებს type-ს სტრუქტურის მიხედვით",
                        "Structural Typing მხოლოდ classes-თან მუშაობს",
                        "Structural Typing არ არსებობს",
                        "Structural Typing მხოლოდ interfaces-თან მუშაობს"
                    ],
                    correct: 0,
                    explanation: "Structural Typing (duck typing) ამოწმებს type-ის თავსებადობას სტრუქტურის მიხედვით."
                },
                {
                    question:"რა არის სტრუქტურული ტიპიზაცია?",
                    code:`interface Person {
    name: string;
}
let person = { name: "ანა", age: 25 };
let p: Person = person; // OK`,
                    options: [
                        "ამოწმებს ტიპს სტრუქტურის მიხედვით",
                        "მხოლოდ კლასებთან მუშაობს",
                        "არ არსებობს",
                        "მხოლოდ ინტერფეისებთან"
                    ],
                    correct: 0,
                    explanation: "სტრუქტურული ტიპიზაცია (duck typing) ამოწმებს ტიპის თავსებადობას სტრუქტურით."
                },
                {
                    question:"რა არის პირობითი ტიპები განაწილებით?",
                    code:`type ExtractString<T> = T extends string ? T : never;
type Result = ExtractString<string | number | boolean>; // string`,
                    options:[
                        "განაწილებულია გაერთიანებაზე",
                        "მხოლოდ მასივებთან",
                        "არ არსებობს",
                        "ჩაანაცვლებს გაერთიანებებს"
                    ],
                    correct: 0,
                    explanation: "პირობითი ტიპები განაწილებენ პირობას გაერთიანების თითოეულ წევრზე."
                },
                {
                    question:"რა არის never ტიპი?",
                    code:`function fail(): never {
    throw new Error("რაღაც არასწორია");
}
let result: never = fail();`,
                    options:[
                        "წარმოადგენს მიუწვდომელ მნიშვნელობებს",
                        "მხოლოდ null-ისთვის",
                        "იგივეა, რაც void",
                        "არ არსებობს"
                    ],
                    correct: 0,
                    explanation: "never ტიპი გამოიყენება ფუნქციებისთვის, რომლებიც არასდროს აბრუნებენ მნიშვნელობას."
                },
                {
                    question:"რა არის ტიპის შემცირება ინტერსექციით?",
                    code:`type A = { a: number };
type B = { b: string };
type C = A & B;
let x: C = { a: 1, b: "გამარჯობა" };`,
                    options:[
                        "შემცირებს ტიპს ინტერსექციის მიხედვით",
                        "მხოლოდ მასივებთან მუშაობს",
                        "არ არის TypeScript-ის ნაწილი",
                        "არ მუშაობს JavaScript-ში"
                    ],
                    correct: 0,
                    explanation: "ინტერსექცია შეამცირებს ტიპს ინტერსექციის მიხედვით."
                },
                {
                    question:"რა არის რეკურსიული ტიპები?",
                    code:`interface Json {
    [key: string]: string | number | boolean | Json | Json[];
}
let data: Json = {
    name: "ანა",
    details: { age: 25, city: "თბილისი" }
};`,
                    options: [
                        "ტიპები, რომლებიც თავადვე მოიხსენიებენ",
                        "მხოლოდ მასივებთან",
                        "არ არსებობს",
                        "ცვლის ინტერფეისებს"
                    ],
                    correct: 0,
                    explanation: "რეკურსიული ტიპები საშუალებას აძლევს ტიპს მოიხსენიოს თავი, მაგ. ჩადგმული სტრუქტურებისთვის."
                },
                {
                    question:"რა არის infer საკვანძო სიტყვა?",
                    code:`type ElementType<T> = T extends (infer U)[] ? U : never;
type Result = ElementType<number[]>; // number`,
                    options: [
                        "აღებულია ტიპი პირობითი ტიპიდან",
                        "მხოლოდ კლასებთან",
                        "არ არსებობს",
                        "ჩაანაცვლებს გენერიკებს"
                    ],
                    correct: 0,
                    explanation: "infer აღებს ტიპს პირობითი ტიპის შიგნით."
                },
                {
                    question:"რა არის შაბლონური ლიტერალური ტიპები?",
                    code:`type Greeting = "გამარჯობა" | "მოგესალმები";
type Message = \`\${Greeting} სამყარო\`;
let msg: Message = "გამარჯობა სამყარო"; // OK`,
                    options: [
                        "ქმნის სტრიქონის ლიტერალების კომბინაციებს",
                        "მხოლოდ მასივებთან",
                        "არ არსებობს",
                        "ჩაანაცვლებს სტრიქონებს"
                    ],
                    correct: 0,
                    explanation: "შაბლონური ლიტერალური ტიპები აერთიანებს ლიტერალებს ახალი სტრიქონის ტიპების შესაქმნელად."
                },
                {
                    question:"რა არის keyof მნიშვნელობის ტიპებთან?",
                    code:`interface User {
    name: string;
    age: number;
}
type NameType = User["name"]; // string`,
                    options: [
                        "აბრუნებს თვისების ტიპს",
                        "მხოლოდ კლასებთან",
                        "არ არსებობს",
                        "ჩაანაცვლებს keyof"
                    ],
                    correct: 0,
                    explanation: "მნიშვნელობის ტიპები აბრუნებენ თვისების ტიპს [key]-ის გამოყენებით."
                },
                {
                    question: "რა არის Never Type?",
                    code: `function fail(): never {
    throw new Error("Something went wrong");
}`,
                    options: [
                        "Never Type წარმოადგენს მნიშვნელობას, რომელიც არასოდეს ხდება",
                        "Never Type გამოიყენება მხოლოდ null-ის ნაცვლად",
                        "Never Type იგივეა, რაც void",
                        "Never Type არ არსებობს"
                    ],
                    correct: 0,
                    explanation: "Never Type გამოიყენება ფუნქციებისთვის, რომლებიც არასოდეს აბრუნებენ მნიშვნელობას."
                }
            ]
        };

        // JavaScript Logic
        let currentCategory = '';
        let currentQuestions = [];
        let currentQuestionIndex = 0;
        let score = 0;
        let startTime = 0;
        let stats = JSON.parse(localStorage.getItem('quizStats')) || {
            totalQuizzes: 0,
            totalScore: 0,
            bestCategory: '',
            bestScore: 0,
            totalTime: 0
        };

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function getCategoryName(category) {
            const names = {
                jsBeginner: 'JavaScript დამწყები',
                jsMedium: 'JavaScript საშუალო',
                jsAdvanced: 'JavaScript მოწინავე',
                tsBeginner: 'TypeScript დამწყები',
                tsMedium: 'TypeScript საშუალო',
                tsAdvanced: 'TypeScript მოწინავე'
            };
            return names[category] || category;
        }

        function startQuiz(category) {
            currentCategory = category;
            currentQuestions = shuffleArray([...quizData[category]]);
            currentQuestionIndex = 0;
            score = 0;
            startTime = Date.now();
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('quizInterface').classList.remove('hidden');
            document.getElementById('resultsScreen').classList.add('hidden');
            showQuestion();
        }

        function showQuestion() {
            const question = currentQuestions[currentQuestionIndex];
            document.getElementById('currentQuestion').textContent = currentQuestionIndex + 1;
            document.getElementById('totalQuestions').textContent = currentQuestions.length;
            document.getElementById('currentScore').textContent = score;
            document.getElementById('questionTitle').textContent = question.question;
            
            const codeBlock = document.getElementById('codeBlock');
            if (question.code) {
                codeBlock.style.display = 'block';
                codeBlock.querySelector('code').textContent = question.code;
            } else {
                codeBlock.style.display = 'none';
            }
            
            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = '';
            question.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'option-btn w-full text-left p-4 rounded-lg bg-white border border-gray-200 hover:bg-gray-50 transition-colors';
                button.innerHTML = `<span class="mr-2">${String.fromCharCode(65 + index)}.</span> ${option}`;
                button.onclick = () => checkAnswer(index);
                optionsContainer.appendChild(button);
            });
            
            document.getElementById('explanationCard').classList.add('hidden');
            updateProgress();
        }

        function updateProgress() {
            const progress = ((currentQuestionIndex + 1) / currentQuestions.length) * 100;
            document.getElementById('progressBar').style.width = `${progress}%`;
        }

        function checkAnswer(selectedIndex) {
            const question = currentQuestions[currentQuestionIndex];
            const buttons = document.querySelectorAll('.option-btn');
            buttons.forEach((button, index) => {
                button.disabled = true;
                if (index === question.correct) {
                    button.classList.add('correct');
                }
                if (index === selectedIndex && index !== question.correct) {
                    button.classList.add('incorrect');
                }
            });
            
            if (selectedIndex === question.correct) {
                score += 10;
                document.getElementById('currentScore').textContent = score;
            }
            
            const explanationCard = document.getElementById('explanationCard');
            document.getElementById('explanationText').textContent = question.explanation;
            explanationCard.classList.remove('hidden');
        }

        function nextQuestion() {
            currentQuestionIndex++;
            if (currentQuestionIndex < currentQuestions.length) {
                showQuestion();
            } else {
                showResults();
            }
        }

        function showResults() {
            const timeTaken = Math.round((Date.now() - startTime) / 60000); // წუთებში
            const percentage = Math.round((score / (currentQuestions.length * 10)) * 100);
            document.getElementById('quizInterface').classList.add('hidden');
            document.getElementById('resultsScreen').classList.remove('hidden');
            document.getElementById('finalScore').textContent = `${percentage}%`;
            document.getElementById('correctAnswers').textContent = score / 10;
            document.getElementById('wrongAnswers').textContent = currentQuestions.length - (score / 10);
            document.getElementById('timeTaken').textContent = `${timeTaken} წთ`;
            
            stats.totalQuizzes++;
            stats.totalScore += percentage;
            stats.totalTime += timeTaken;
            if (percentage > stats.bestScore || (percentage === stats.bestScore && getCategoryName(currentCategory).length < getCategoryName(stats.bestCategory).length)) {
                stats.bestScore = percentage;
                stats.bestCategory = currentCategory;
            }
            localStorage.setItem('quizStats', JSON.stringify(stats));
            updateStats();
        }

        function updateStats() {
            document.getElementById('totalQuizzes').textContent = stats.totalQuizzes;
            document.getElementById('averageScore').textContent = stats.totalQuizzes ? `${Math.round(stats.totalScore / stats.totalQuizzes)}%` : '0%';
            document.getElementById('bestCategory').textContent = stats.bestCategory ? getCategoryName(stats.bestCategory) : '-';
            document.getElementById('timeSpent').textContent = `${stats.totalTime} წთ`;
        }

        function restartQuiz() {
            startQuiz(currentCategory);
        }

        function backToMenu() {
            document.getElementById('quizInterface').classList.add('hidden');
            document.getElementById('resultsScreen').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        }

        function switchLanguage(lang) {
            const translations = {
                ge: {
                    title: 'JavaScript & TypeScript ქვიზი',
                    subtitle: 'შეამოწმეთ თქვენი ცოდნა პროგრამირებაში',
                    backToMenu: 'მთავარ მენიუში დაბრუნება',
                    nextQuestion: 'შემდეგი კითხვა',
                    restartQuiz: 'კვლავ სცადეთ',
                    statsTitle: 'თქვენი სტატისტიკა',
                    totalQuizzes: 'მოსრულებული ქვიზები',
                    averageScore: 'საშუალო ქულა',
                    bestCategory: 'საუკეთესო კატეგორია',
                    timeSpent: 'დახარჯული დრო'
                },
                en: {
                    title: 'JavaScript & TypeScript Quiz',
                    subtitle: 'Test your programming knowledge',
                    backToMenu: 'Back to Main Menu',
                    nextQuestion: 'Next Question',
                    restartQuiz: 'Try Again',
                    statsTitle: 'Your Statistics',
                    totalQuizzes: 'Completed Quizzes',
                    averageScore: 'Average Score',
                    bestCategory: 'Best Category',
                    timeSpent: 'Time Spent'
                }
            };
            
            const t = translations[lang];
            document.querySelector('h1').textContent = t.title;
            document.querySelector('p.text-xl').textContent = t.subtitle;
            document.querySelector('button[onclick="backToMenu()"]').childNodes[2].textContent = t.backToMenu;
            document.querySelector('#explanationCard button').childNodes[2].textContent = t.nextQuestion;
            document.querySelector('#resultsScreen button[onclick="restartQuiz()"]').childNodes[2].textContent = t.restartQuiz;
            document.querySelector('#mainMenu h3.text-xl').textContent = t.statsTitle;
            document.querySelector('#mainMenu .text-sm:nth-child(2)').textContent = t.totalQuizzes;
            document.querySelector('#mainMenu .text-sm:nth-child(4)').textContent = t.averageScore;
            document.querySelector('#mainMenu .text-sm:nth-child(6)').textContent = t.bestCategory;
            document.querySelector('#mainMenu .text-sm:nth-child(8)').textContent = t.timeSpent;
            
            document.querySelectorAll('.language-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`button[onclick="switchLanguage('${lang}')"]`).classList.add('active');
        }

        window.onload = updateStats;
    </script>
</body>
</html>